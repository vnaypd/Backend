import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
export const SELF = null;
export const ALL_VALUES = {};
export const ALL_MEMBERS = [];
const NEXT_LEVEL = "*";
const processObj = (obj, processFunc, keyNodes) => {
    if (obj !== undefined) {
        if (keyNodes == null) {
            return processFunc(obj);
        }
        else {
            const keys = Object.keys(keyNodes);
            const goToNextLevel = keys.length === 1 && keys[0] === NEXT_LEVEL;
            const someChildren = keys.length >= 1 && !goToNextLevel;
            const allChildren = keys.length === 0;
            if (someChildren) {
                return processKeysInObj(obj, processFunc, keyNodes);
            }
            else if (allChildren) {
                return processAllKeysInObj(obj, processFunc, SELF);
            }
            else if (goToNextLevel) {
                return Object.entries(obj ?? {}).reduce((acc, [k, v]) => {
                    acc[k] = processObj(v, processFunc, keyNodes[NEXT_LEVEL]);
                    return acc;
                }, (Array.isArray(obj) ? [] : {}));
            }
        }
    }
    return undefined;
};
const processKeysInObj = (obj, processFunc, keyNodes) => {
    let accumulator;
    if (Array.isArray(obj)) {
        accumulator = [...obj];
    }
    else {
        accumulator = { ...obj };
    }
    for (const [nodeKey, nodes] of Object.entries(keyNodes)) {
        const processedValue = processObj(obj[nodeKey], processFunc, nodes);
        if (processedValue !== undefined) {
            accumulator[nodeKey] = processedValue;
        }
    }
    return accumulator;
};
const processAllKeysInObj = (obj, processFunc, keyNodes) => {
    if (Array.isArray(obj)) {
        return obj.map((item) => processObj(item, processFunc, keyNodes));
    }
    return Object.entries(obj).reduce((acc, [key, value]) => {
        const processedValue = processObj(value, processFunc, keyNodes);
        if (processedValue !== undefined) {
            acc[key] = processedValue;
        }
        return acc;
    }, {});
};
function copyWithoutFunctions(o, depth = 0) {
    if (depth > 1000) {
        throw new Error("Recursive copy depth exceeded 1000. Please set options.convertClassInstanceToMap to false and manually remove functions from your data object.");
    }
    if (typeof o === "object" || typeof o === "function") {
        if (Array.isArray(o)) {
            return o.filter((item) => typeof item !== "function").map((item) => copyWithoutFunctions(item, depth + 1));
        }
        if (o === null) {
            return null;
        }
        const copy = {};
        for (const [key, value] of Object.entries(o)) {
            if (typeof value !== "function") {
                copy[key] = copyWithoutFunctions(value, depth + 1);
            }
        }
        return copy;
    }
    else {
        return o;
    }
}
export const marshallInput = (obj, keyNodes, options) => {
    let _obj = obj;
    if (options?.convertClassInstanceToMap) {
        _obj = copyWithoutFunctions(obj);
    }
    const marshallFunc = (toMarshall) => marshall(toMarshall, options);
    return processKeysInObj(_obj, marshallFunc, keyNodes);
};
export const unmarshallOutput = (obj, keyNodes, options) => {
    const unmarshallFunc = (toMarshall) => unmarshall(toMarshall, options);
    return processKeysInObj(obj, unmarshallFunc, keyNodes);
};
